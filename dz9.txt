1. Дан массив из n элементов, начиная с 1. Каждый следующий элемент равен (предыдущий + 1). Но в массиве гарантированно 1 число пропущено. Необходимо вывести на экран пропущенное число.
Примеры:
[1, 2 ,3, 4, 5, 6, 7, 8, 9, 10, 12, 13, 14, 15, 16] => 11
[1, 2, 4, 5, 6] => 3
[] => 1

2. Рассмотреть структуры данных Nested Sets и Clojure table (см. ссылки в желтом закрепленном сообщении)
3*. Доработать алгоритм бинарного поиска для нахождения кол-ва повторений в массиве. Сложность O(logn) не должна измениться. Учтите, что массив длиной n может состоять из одного значения [4, 4, 4, 4, ...(n)..., 4]
4**. Реализовать на РНР сортировку слиянием (не копируя готовое :) )
.
.
Для тех, кто уже проходил данный курс:

1. Отсортировать массив, состоящий из экземпляров класса Notebook в количестве 5000 штук.
Условия для сортировки:
1) по цене. От 500 до 1000 долларов с шагом в 100
если цена равная, то
2) по кол-ву оперативной памяти (от 4 до 12 с шагом 4)
если памяти тоже равное количество, то 3) по производителю:
Lenuvo > Asos > MacNote > Eser > Xamiou
Добиваться максимально оптимальной сложности О-большая

2. В метод permutations("abab") подается строка. Вы должны собрать массив из всех вариаций входных букв, собрав из этого массив. Важный момент: Вы должны игнорировать повторения. Конечный массив должен быть отсортирован
Примеры:

permutations('a'); // => ['a']
permutations('ab'); // => ['ab', 'ba']
permutations('aabb'); // => ['aabb', 'abab', 'abba', 'baab', 'baba', 'bbaa']

3*. Число 10 можно записать в виде суммы простых чисел ровно пятью различными способами:
7 + 3
5 + 5
5 + 3 + 2
3 + 3 + 2 + 2
2 + 2 + 2 + 2 + 2

Какое наименьшее число можно записать в виде суммы простых чисел по крайней мере пятью тысячами различных способов?